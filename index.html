<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tethered Souls - Physics Tetris</title>
    <style>
        body {
            margin: 0;
            background: #050505;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 60px rgba(100, 0, 255, 0.2);
        }
        canvas {
            background: #0a0a10;
            display: block;
            border: 2px solid #333;
        }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box;
            z-index: 500;
        }
        .top-bar { display: flex; justify-content: space-between; width: 100%; text-shadow: 1px 1px 4px black; }
        .hp-bar-container { width: 200px; background: #333; height: 20px; border: 2px solid white; position: relative; }
        .hp-fill { height: 100%; transition: width 0.2s; }
        #hp-blue { background: cyan; width: 100%; box-shadow: 0 0 10px cyan; }
        #hp-red { background: #ff4444; width: 100%; box-shadow: 0 0 10px #ff4444; }
        
        #mission-display {
            position: absolute; top: 50px; width: 100%;
            text-align: center; font-size: 24px; font-weight: bold;
            color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 600; cursor: pointer;
            backdrop-filter: blur(5px);
        }
        #start-screen h1 { font-size: 50px; color: cyan; margin: 0; text-shadow: 0 0 20px cyan; }
        #upgrade-modal {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95); border: 2px solid #ffd700;
            padding: 20px; text-align: center; pointer-events: auto;
            border-radius: 10px; z-index: 600; min-width: 400px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }
        .upgrade-btn {
            display: block; width: 100%; padding: 15px; margin: 10px 0;
            background: #333; color: white; border: 1px solid #555;
            cursor: pointer; font-size: 18px; transition: 0.2s;
        }
        .upgrade-btn:hover { background: #444; border-color: cyan; transform: scale(1.02); }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="1000" height="700"></canvas>
    
    <div id="start-screen" onclick="startGame()">
        <h1>PHYSICS TETRIS</h1>
        <p>BAÅžLAMAK Ä°Ã‡Ä°N TIKLA</p>
        <div style="margin-top:20px; font-size:14px; color:#aaa;">
            MAVÄ°: W,A,S,D + SHIFT | KIRMIZI: YÃ¶n TuÅŸlarÄ± + ENTER
            <br><br>
            ÅžEKÄ°LLERÄ° Ä°T, SIKIÅžTIR VE SATIRLARI YOK ET!
        </div>
    </div>

    <div id="ui-layer">
        <div class="top-bar">
            <div>
                <div style="color:cyan; margin-bottom:5px;">MAVÄ°</div>
                <div class="hp-bar-container"><div id="hp-blue" class="hp-fill"></div></div>
            </div>
            <div>
                <div style="text-align:right; color:#ff4444; margin-bottom:5px;">KIRMIZI</div>
                <div class="hp-bar-container"><div id="hp-red" class="hp-fill"></div></div>
            </div>
        </div>
    </div>

    <div id="mission-display">
        <div id="mission-text">ISINMA TURU</div>
        <div id="mission-timer">30s</div>
    </div>

    <div id="upgrade-modal">
        <h2>GÃ–REV TAMAMLANDI!</h2>
        <div id="upgrade-options"></div>
    </div>
</div>

<script>
// --- Audio System ---
const CUSTOM_HEART_SOUND_URL = 'https://raw.githubusercontent.com/l4Vuk/sites/main/sehburyeah.mp3'; 
const heartAudio = new Audio(CUSTOM_HEART_SOUND_URL);
heartAudio.volume = 0.5;

const AudioSys = {
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    playTone(freq, type, duration, vol=0.1) {
        if(this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playShoot() { this.playTone(400 + Math.random()*200, 'square', 0.1, 0.05); },
    playHit() { this.playTone(100, 'sawtooth', 0.2, 0.1); },
    playShield() { this.playTone(800, 'sine', 0.1, 0.1); },
    playLineClear() { 
        this.playTone(400, 'sine', 0.1, 0.2);
        setTimeout(()=>this.playTone(600, 'sine', 0.1, 0.2), 100);
        setTimeout(()=>this.playTone(800, 'square', 0.2, 0.2), 200);
    },
    playLoveSound() {
        heartAudio.currentTime = 0;
        heartAudio.play().catch(e => console.log(e));
    }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const GAME = {
    width: 1000, height: 700,
    state: 'MENU',
    difficulty: 1, time: 0,
    gameSpeed: 1.0,
    maxTetherDist: 400,
    mission: { active: false, type: null, target: 0, current: 0, endTime: 0, failedDamage: false }
};

const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

// --- TETROMINO SHAPES ---
const SHAPES = {
    I: { color: '#00f0f0', map: [[1,1,1,1]] },
    J: { color: '#0000f0', map: [[1,0,0],[1,1,1]] },
    L: { color: '#f0a000', map: [[0,0,1],[1,1,1]] },
    O: { color: '#f0f000', map: [[1,1],[1,1]] },
    S: { color: '#00f000', map: [[0,1,1],[1,1,0]] },
    T: { color: '#a000f0', map: [[0,1,0],[1,1,1]] },
    Z: { color: '#f00000', map: [[1,1,0],[0,1,1]] }
};
const BLOCK_SIZE = 50;

// --- TETROMINO CLASS ---
class Tetromino {
    constructor() {
        const keys = Object.keys(SHAPES);
        const type = keys[Math.floor(Math.random() * keys.length)];
        this.def = SHAPES[type];
        this.map = this.def.map;
        this.color = this.def.color;
        
        // Grid'e hizalÄ± baÅŸla
        this.x = Math.floor(Math.random() * (GAME.width / BLOCK_SIZE - this.map[0].length)) * BLOCK_SIZE;
        this.y = -BLOCK_SIZE * 3;
        this.vy = 2 + (Math.random() * 1);
        this.grounded = false;
        
        // Physics properties
        this.mass = 10;
    }

    // BloÄŸun dolu olan hÃ¼crelerinin dÃ¼nya Ã¼zerindeki koordinatlarÄ±nÄ± (Rect olarak) dÃ¶ndÃ¼rÃ¼r
    getRects(offsetX = 0, offsetY = 0) {
        let rects = [];
        for(let r=0; r<this.map.length; r++) {
            for(let c=0; c<this.map[r].length; c++) {
                if(this.map[r][c] === 1) {
                    rects.push({
                        x: this.x + (c * BLOCK_SIZE) + offsetX,
                        y: this.y + (r * BLOCK_SIZE) + offsetY,
                        w: BLOCK_SIZE,
                        h: BLOCK_SIZE
                    });
                }
            }
        }
        return rects;
    }

    update(dt, allBlocks) {
        if (this.grounded) return;

        // YerÃ§ekimi hareketi (Basit Collision Check)
        let nextY = this.y + (this.vy * 60 * dt * GAME.gameSpeed);
        
        if (!this.checkCollision(0, nextY - this.y, allBlocks)) {
            this.y = nextY;
        } else {
            // Ã‡arpÄ±ÅŸma var, aÅŸaÄŸÄ± inemiyoruz -> Grounded
            // Grid'e hizala (Snap)
            this.y = Math.floor(this.y / 10) * 10; // Hafif snap
            this.grounded = true;
        }

        // Zemin kontrolÃ¼ (Ekstra gÃ¼venlik)
        let rects = this.getRects();
        for(let r of rects) {
            if (r.y + r.h >= GAME.height) {
                this.y -= (r.y + r.h - GAME.height);
                this.grounded = true;
            }
        }
    }

    // Gelecekteki bir pozisyonda Ã§arpÄ±ÅŸma var mÄ±?
    checkCollision(dx, dy, allBlocks) {
        let myRects = this.getRects(dx, dy);
        
        // 1. Zemin ve Duvar KontrolÃ¼
        for(let r of myRects) {
            if (r.y + r.h > GAME.height) return true; // Zemin
            if (r.x < 0) return true; // Sol Duvar
            if (r.x + r.w > GAME.width) return true; // SaÄŸ Duvar
        }

        // 2. DiÄŸer Bloklarla Kontrol
        for(let other of allBlocks) {
            if (other === this) continue;
            let otherRects = other.getRects();
            
            for(let myR of myRects) {
                for(let otherR of otherRects) {
                    // AABB Ã‡arpÄ±ÅŸma
                    if (myR.x < otherR.x + otherR.w &&
                        myR.x + myR.w > otherR.x &&
                        myR.y < otherR.y + otherR.h &&
                        myR.y + myR.h > otherR.y) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    draw(ctx) {
        ctx.fillStyle = this.color; // Renkli
        ctx.strokeStyle = 'white'; // DÄ±ÅŸ Ã§izgi
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;

        let rects = this.getRects();
        for(let r of rects) {
            ctx.fillRect(r.x, r.y, r.w, r.h);
            ctx.strokeRect(r.x, r.y, r.w, r.h);
        }
        ctx.shadowBlur = 0;
    }
}

// ... Player, BackgroundGrid, vb. sÄ±nÄ±flarÄ± burada ...
class BackgroundGrid {
    constructor(width, height, cellSize) {
        this.cellSize = cellSize;
        this.cols = Math.ceil(width / cellSize);
        this.rows = Math.ceil(height / cellSize);
        this.cells = [];
        for(let i=0; i<this.cols * this.rows; i++) { this.cells.push({ val: 0 }); }
    }
    update(p1, p2) {
        for(let i=0; i<this.cells.length; i++) {
            this.cells[i].val *= 0.92;
            if(this.cells[i].val < 0.01) this.cells[i].val = 0;
        }
        [p1, p2].forEach(p => {
            let cx = Math.floor(p.x / this.cellSize);
            let cy = Math.floor(p.y / this.cellSize);
            if(cx >= 0 && cx < this.cols && cy >= 0 && cy < this.rows) {
                let index = cy * this.cols + cx;
                this.cells[index].val = 1.0;
                [index-1, index+1, index-this.cols, index+this.cols].forEach(n => {
                    if(this.cells[n]) this.cells[n].val = Math.max(this.cells[n].val, 0.5);
                });
            }
        });
    }
    draw(ctx) {
        ctx.lineWidth = 1;
        for(let y=0; y<this.rows; y++) {
            for(let x=0; x<this.cols; x++) {
                let index = y * this.cols + x;
                let cell = this.cells[index];
                if(cell.val > 0.05) {
                    let posX = x * this.cellSize, posY = y * this.cellSize, center = this.cellSize / 2;
                    let scale = 1 - (cell.val * 0.95);
                    ctx.save(); ctx.translate(posX + center, posY + center); ctx.scale(scale, scale);
                    ctx.strokeStyle = `rgba(100, 200, 255, ${cell.val * 0.6})`;
                    ctx.fillStyle = `rgba(100, 200, 255, ${cell.val * 0.1})`;
                    ctx.beginPath(); ctx.rect(-center, -center, this.cellSize, this.cellSize);
                    ctx.fill(); ctx.stroke(); ctx.restore();
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
                    ctx.strokeRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
                }
            }
        }
    }
}

class Player {
    constructor(x, y, color, role) {
        this.x = x; this.y = y;
        this.color = color; this.role = role;
        this.hp = 100; this.maxHp = 100;
        this.baseSpeed = 300;
        this.speedMult = 1.0;
        this.dashCooldown = 0;
        this.radius = 15;
    }

    update(dt, partner) {
        if (this.dashCooldown > 0) this.dashCooldown -= dt;

        let dx = 0, dy = 0;
        if (this.role === 'blue') {
            if (keys['KeyW']) dy = -1;
            if (keys['KeyS']) dy = 1;
            if (keys['KeyA']) dx = -1;
            if (keys['KeyD']) dx = 1;
            if (keys['ShiftLeft'] && this.dashCooldown <= 0 && (dx||dy)) this.performDash(dx, dy, partner);
        } else {
            if (keys['ArrowUp']) dy = -1;
            if (keys['ArrowDown']) dy = 1;
            if (keys['ArrowLeft']) dx = -1;
            if (keys['ArrowRight']) dx = 1;
            if (keys['Enter'] && this.dashCooldown <= 0 && (dx||dy)) this.performDash(dx, dy, partner);
        }

        if (dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            dx /= len; dy /= len;
        }

        const dist = Math.hypot(this.x - partner.x, this.y - partner.y);
        let tension = dist / GAME.maxTetherDist;
        if (tension > 1) tension = 1;

        let physicsSpeedMod = 1.0 - (tension * 0.95); 
        if (physicsSpeedMod < 0.05) physicsSpeedMod = 0.05;

        const finalSpeed = this.baseSpeed * this.speedMult * physicsSpeedMod;

        this.x += dx * finalSpeed * dt * GAME.gameSpeed;
        this.y += dy * finalSpeed * dt * GAME.gameSpeed;

        this.x = Math.max(15, Math.min(GAME.width-15, this.x));
        this.y = Math.max(15, Math.min(GAME.height-15, this.y));
    }

    performDash(dx, dy, partner) {
        this.dashCooldown = 15.0; 
        this.x += dx * 100;
        this.y += dy * 100;
        setTimeout(() => {
            if (GAME.state === 'GAMEOVER') return;
            partner.x = this.x; partner.y = this.y;
            particles.push(new Particle(this.x, this.y, 'white', 'Ã‡EKÄ°LDÄ°!', 20));
            AudioSys.playTone(600, 'square', 0.1);
        }, 200);
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        if (this.dashCooldown > 0) {
            ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(this.x, this.y, 22, 0, (this.dashCooldown/15.0) * Math.PI*2); ctx.stroke();
        }
    }
}

class Bullet {
    constructor(x, y, target, isRed) {
        this.x = x; this.y = y; this.isRed = isRed;
        this.color = isRed ? '#ff4444' : 'cyan';
        const angle = Math.atan2(target.y - y, target.x - x);
        const speed = 150 + (GAME.difficulty * 15);
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 10;
    }
    update(dt) { this.x += this.vx * dt * GAME.gameSpeed; this.y += this.vy * dt * GAME.gameSpeed; this.life -= dt; }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.fill(); ctx.shadowBlur = 0;
    }
}

class Item {
    constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.timer = 15; }
    draw(ctx) {
        ctx.font = "20px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
        if (this.type === 'gold') { ctx.fillStyle = "gold"; ctx.fillText("ðŸ’°", this.x, this.y); }
        else {
            let c = (this.type === 'heart_blue') ? 'cyan' : (this.type === 'heart_red') ? 'red' : '#0f0';
            ctx.fillStyle = c; ctx.fillText("â™¥", this.x, this.y);
        }
    }
}

class Particle {
    constructor(x, y, color, text, size=14) { this.x = x; this.y = y; this.color = color; this.text = text; this.life = 1.0; this.size = size; }
    update(dt) { this.y -= 30 * dt; this.life -= dt; }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px Arial`;
        ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1.0;
    }
}

// --- INIT & LOOP ---
const P1 = new Player(400, 350, 'cyan', 'blue');
const P2 = new Player(600, 350, '#ff4444', 'red');
const bgGrid = new BackgroundGrid(GAME.width, GAME.height, BLOCK_SIZE);
let bullets = [], items = [], particles = [], obstacles = [];
let lastTime = 0, loveModeTimer = 0;

function startGame() {
    document.getElementById('start-screen').style.display = 'none';
    AudioSys.playTone(0, 'sine', 0);
    GAME.state = 'WARMUP';
    requestAnimationFrame(gameLoop);
}

function spawnEnemy() {
    const side = Math.floor(Math.random() * 4);
    let x, y;
    if (side===0) {x=Math.random()*GAME.width; y=-20;}
    if (side===1) {x=Math.random()*GAME.width; y=GAME.height+20;}
    if (side===2) {x=-20; y=Math.random()*GAME.height;}
    if (side===3) {x=GAME.width+20; y=Math.random()*GAME.height;}
    const isRed = Math.random() > 0.5;
    bullets.push(new Bullet(x, y, isRed ? P2 : P1, isRed));
}

function updateGame(dt) {
    if (GAME.state === 'UPGRADE') return;
    
    GAME.time += dt;
    if (loveModeTimer > 0) { loveModeTimer -= dt; if (loveModeTimer <= 0) GAME.gameSpeed = 1.0; }

    bgGrid.update(P1, P2);

    if (Math.random() < (0.015 + (GAME.difficulty * 0.005)) * GAME.gameSpeed) spawnEnemy();
    if (Math.random() < 0.005) items.push(new Item(Math.random()*GAME.width, Math.random()*GAME.height, 'gold'));
    
    // SPAWN TETROMINO
    if (Math.random() < 0.003 + (GAME.difficulty * 0.0005)) { obstacles.push(new Tetromino()); }

    if (Math.random() < 0.002) {
        const r = Math.random();
        let t = 'heart_green';
        if (r < 0.33) t = 'heart_blue'; else if (r < 0.66) t = 'heart_red';
        items.push(new Item(Math.random()*GAME.width, Math.random()*GAME.height, t));
    }

    P1.update(dt, P2); P2.update(dt, P1);
    
    const dist = Math.hypot(P1.x - P2.x, P1.y - P2.y);
    if (dist > GAME.maxTetherDist + 10) {
        const mx = (P1.x+P2.x)/2, my = (P1.y+P2.y)/2;
        P1.x = mx-10; P1.y = my; P2.x = mx+10; P2.y = my;
        particles.push(new Particle(mx, my, 'white', 'KOPMA!', 25));
    }

    bullets.forEach(b => b.update(dt));
    items.forEach(i => i.timer -= dt);
    
    // Tetromino Update
    obstacles.forEach(o => o.update(dt, obstacles));
    
    particles.forEach(p => p.update(dt));
    
    bullets = bullets.filter(b => b.life > 0 && b.x > -50 && b.x < GAME.width+50);
    items = items.filter(i => i.timer > 0);
    particles = particles.filter(p => p.life > 0);

    checkBlockAbsorb();
    checkLineClears();
    checkCollisions();
    updateMission(dt);
}

// YENÄ° Ä°TME FÄ°ZÄ°ÄžÄ°
function resolveBlockPush(p, block) {
    // 1. Oyuncu bloÄŸun iÃ§inde mi veya Ã§ok yakÄ±nÄ±nda mÄ±?
    // BloÄŸun her bir karesi (sub-rect) ile oyuncuyu kontrol et
    let rects = block.getRects();
    let hitRect = null;
    let pushX = 0;
    
    for (let r of rects) {
        // AABB vs Circle
        let testX = p.x;
        let testY = p.y;
        if (p.x < r.x) testX = r.x;
        else if (p.x > r.x + r.w) testX = r.x + r.w;
        if (p.y < r.y) testY = r.y;
        else if (p.y > r.y + r.h) testY = r.y + r.h;
        
        let distX = p.x - testX;
        let distY = p.y - testY;
        let distance = Math.sqrt((distX*distX) + (distY*distY));

        if (distance <= p.radius) {
            hitRect = r;
            // Ä°tme yÃ¶nÃ¼nÃ¼ belirle (Sadece yatay itme serbest olsun, daha stabil)
            // EÄŸer oyuncu bloÄŸun solundaysa -> SaÄŸa it
            if (p.x < r.x + r.w/2) pushX = 2;
            else pushX = -2;
            break;
        }
    }

    if (hitRect && pushX !== 0) {
        // BloÄŸu itmeyi dene
        if (!block.checkCollision(pushX, 0, obstacles)) {
            block.x += pushX;
        }
    }
}

function checkBlockAbsorb() {
    obstacles.forEach(o => {
        let rects = o.getRects();
        // Mermileri Yut
        bullets = bullets.filter(b => {
            for(let r of rects) {
                if (b.x > r.x && b.x < r.x + r.w && b.y > r.y && b.y < r.y + r.h) return false;
            }
            return true;
        });
        // ItemlarÄ± Yut
        items = items.filter(i => {
            for(let r of rects) {
                if (i.x > r.x && i.x < r.x + r.w && i.y > r.y && i.y < r.y + r.h) return false;
            }
            return true;
        });
    });
}

function checkLineClears() {
    // SatÄ±r Silme MantÄ±ÄŸÄ±
    const rows = Math.floor(GAME.height / BLOCK_SIZE);
    let rowCounts = new Array(rows).fill(0);
    
    // Her bloÄŸun her hÃ¼cresini say
    obstacles.forEach(o => {
        let rects = o.getRects();
        for(let r of rects) {
            let rowIdx = Math.floor((r.y + r.h/2) / BLOCK_SIZE);
            if(rowIdx >= 0 && rowIdx < rows) rowCounts[rowIdx]++;
        }
    });

    const blocksPerRow = Math.floor(GAME.width / BLOCK_SIZE);
    
    // SatÄ±r doldu mu?
    for(let r=rows-1; r>=0; r--) {
        if (rowCounts[r] >= blocksPerRow - 1) { // %95 doluluk yeter
            destroyRow(r);
        }
    }
}

function destroyRow(rowIndex) {
    let yMin = rowIndex * BLOCK_SIZE;
    let yMax = (rowIndex + 1) * BLOCK_SIZE;
    
    // BloklarÄ± modifiye etmemiz lazÄ±m.
    // Tetris bloÄŸu bir bÃ¼tÃ¼n, bir satÄ±rÄ± silinince bÃ¶lÃ¼nmesi gerekir.
    // Basit Ã§Ã¶zÃ¼m: O satÄ±rdaki hÃ¼creleri matristen sil. EÄŸer matris boÅŸalÄ±rsa bloÄŸu sil.
    
    let toRemove = [];

    obstacles.forEach(o => {
        // BloÄŸun map'ini gÃ¼ncelle
        // BloÄŸun Y pozisyonu ile rowIndex'i eÅŸleÅŸtir
        let blockRowStart = Math.round(o.y / BLOCK_SIZE);
        
        // BloÄŸun iÃ§indeki satÄ±r indexi
        let internalRow = rowIndex - blockRowStart;
        
        if (internalRow >= 0 && internalRow < o.map.length) {
            // Bu satÄ±rÄ± 0'la
            for(let c=0; c<o.map[internalRow].length; c++) {
                if(o.map[internalRow][c] === 1) {
                    o.map[internalRow][c] = 0;
                    particles.push(new Particle(o.x + c*BLOCK_SIZE, o.y + internalRow*BLOCK_SIZE, o.color, 'BOOM!', 20));
                }
            }
            // EÄŸer blok tamamen boÅŸaldÄ±ysa silme listesine ekle
            let isEmpty = true;
            for(let r=0; r<o.map.length; r++) {
                for(let c=0; c<o.map[r].length; c++) {
                    if(o.map[r][c]===1) isEmpty = false;
                }
            }
            if(isEmpty) toRemove.push(o);
        }
    });

    obstacles = obstacles.filter(o => !toRemove.includes(o));
    AudioSys.playLineClear();
    GAME.mission.current += 10;
}

function checkCollisions() {
    obstacles.forEach(block => { resolveBlockPush(P1, block); resolveBlockPush(P2, block); });

    bullets = bullets.filter(b => {
        const d1 = Math.hypot(b.x-P1.x, b.y-P1.y);
        const d2 = Math.hypot(b.x-P2.x, b.y-P2.y);
        
        if (d1 < 21) {
            if (b.isRed) { 
                particles.push(new Particle(P1.x, P1.y, 'cyan', 'BLOK!'));
                AudioSys.playShield();
                if(GAME.mission.active && GAME.mission.type === 'KILL_RED') GAME.mission.current++;
                return false;
            } else {
                P1.hp -= 10;
                particles.push(new Particle(P1.x, P1.y, 'red', '-10 CAN'));
                AudioSys.playHit();
                GAME.mission.failedDamage = true;
                return false;
            }
        }
        if (d2 < 21) {
            if (!b.isRed) {
                particles.push(new Particle(P2.x, P2.y, '#ff4444', 'BLOK!'));
                AudioSys.playShield();
                if(GAME.mission.active && GAME.mission.type === 'KILL_BLUE') GAME.mission.current++;
                return false;
            } else {
                P2.hp -= 10;
                particles.push(new Particle(P2.x, P2.y, 'red', '-10 CAN'));
                AudioSys.playHit();
                GAME.mission.failedDamage = true;
                return false;
            }
        }
        return true;
    });

    items = items.filter(i => {
        const d1 = Math.hypot(i.x-P1.x, i.y-P1.y);
        const d2 = Math.hypot(i.x-P2.x, i.y-P2.y);
        let picker = null;
        if (d1 < 20) picker = P1; else if (d2 < 20) picker = P2;

        if (picker) {
            if (i.type === 'gold') {
                GAME.mission.current++;
                particles.push(new Particle(i.x, i.y, 'gold', '+1 ALTIN'));
                AudioSys.playShoot();
                return false;
            } else {
                let valid = (i.type==='heart_green') || (i.type==='heart_blue' && picker===P1) || (i.type==='heart_red' && picker===P2);
                if (valid) {
                    picker.hp = Math.min(picker.maxHp, picker.hp+20);
                    activateLoveMode();
                    return false;
                }
            }
        }
        return true;
    });
}

function activateLoveMode() {
    loveModeTimer = 2.0;
    GAME.gameSpeed = 0.3;
    bullets = [];
    particles.push(new Particle(500, 350, 'pink', 'â™¥ SEHBURYEAH! â™¥', 30));
    AudioSys.playLoveSound();
}

function updateMission(dt) {
    const elText = document.getElementById('mission-text');
    const elTimer = document.getElementById('mission-timer');
    
    if (GAME.state === 'WARMUP') {
        if (GAME.time > 30) { GAME.state = 'PLAYING'; startNewMission(); }
        else { elText.innerText = "ISINMA TURU"; elTimer.innerText = Math.ceil(30-GAME.time)+"s"; }
        return;
    }

    if (!GAME.mission.active) return;
    const timeLeft = GAME.mission.endTime - GAME.time;
    elTimer.innerText = Math.ceil(timeLeft) + "s";
    
    if (GAME.mission.type === 'KILL_RED') elText.innerText = `MAVÄ°: ${GAME.mission.target - GAME.mission.current} KÄ±rmÄ±zÄ± Yok Et`;
    if (GAME.mission.type === 'KILL_BLUE') elText.innerText = `KIRMIZI: ${GAME.mission.target - GAME.mission.current} Mavi Yok Et`;
    if (GAME.mission.type === 'GOLD') elText.innerText = `TOPLAM: ${GAME.mission.target - GAME.mission.current} AltÄ±n Topla`;
    if (GAME.mission.type === 'SURVIVE') elText.innerText = `HASAR ALMADAN HAYATTA KAL`;

    let success = false, fail = false;
    if (timeLeft <= 0) {
        if (GAME.mission.type === 'SURVIVE' && !GAME.mission.failedDamage) success = true;
        else fail = true;
    }
    if (GAME.mission.type !== 'SURVIVE' && GAME.mission.current >= GAME.mission.target) success = true;
    if (GAME.mission.type === 'SURVIVE' && GAME.mission.failedDamage) fail = true;

    if (fail) {
        P1.hp = Math.floor(P1.hp/2); P2.hp = Math.floor(P2.hp/2);
        particles.push(new Particle(500, 350, 'red', 'BAÅžARISIZ! CAN -%50', 40));
        startNewMission();
    } else if (success) {
        GAME.state = 'UPGRADE';
        showUpgradeMenu();
    }
}

function startNewMission() {
    GAME.mission.active = true;
    GAME.mission.failedDamage = false;
    GAME.mission.current = 0;
    const types = ['KILL_RED', 'KILL_BLUE', 'GOLD', 'SURVIVE'];
    GAME.mission.type = types[Math.floor(Math.random()*types.length)];
    
    if (GAME.mission.type.includes('KILL')) GAME.mission.target = 3 + GAME.difficulty;
    if (GAME.mission.type === 'GOLD') GAME.mission.target = 5 + GAME.difficulty;
    
    GAME.mission.endTime = GAME.time + 30;
}

function showUpgradeMenu() {
    const modal = document.getElementById('upgrade-modal');
    const container = document.getElementById('upgrade-options');
    container.innerHTML = '';
    modal.style.display = 'block';
    
    const opts = [
        {t:"Mavi HÄ±z +%20", f:()=>{P1.speedMult+=0.2}},
        {t:"KÄ±rmÄ±zÄ± HÄ±z +%20", f:()=>{P2.speedMult+=0.2}},
        {t:"Tam Ä°yileÅŸme", f:()=>{P1.hp=100; P2.hp=100;}},
        {t:"Ä°p UzunluÄŸu +50", f:()=>{GAME.maxTetherDist+=50;}}
    ];

    for(let i=0; i<3; i++) {
        const o = opts[Math.floor(Math.random()*opts.length)];
        const btn = document.createElement('button');
        btn.className = 'upgrade-btn'; btn.innerText = o.t;
        btn.onclick = () => {
            o.f(); modal.style.display = 'none';
            GAME.state = 'PLAYING'; GAME.difficulty++;
            startNewMission();
        };
        container.appendChild(btn);
    }
}

function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    ctx.clearRect(0,0,GAME.width, GAME.height);

    if (P1.hp <= 0 && P2.hp <= 0) {
        ctx.fillStyle = 'red'; ctx.font = "60px Arial"; ctx.fillText("OYUN BÄ°TTÄ°", 350, 350);
        return;
    }

    if (GAME.state !== 'MENU') updateGame(dt);

    bgGrid.draw(ctx);

    const dist = Math.hypot(P1.x-P2.x, P1.y-P2.y);
    const tension = Math.min(1, dist / GAME.maxTetherDist);
    ctx.strokeStyle = `rgb(255, ${255 * (1-tension)}, ${255 * (1-tension)})`;
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(P1.x, P1.y); ctx.lineTo(P2.x, P2.y); ctx.stroke();

    items.forEach(i => i.draw(ctx));
    P1.draw(ctx); P2.draw(ctx);
    bullets.forEach(b => b.draw(ctx));
    
    // EN ÃœSTTE TETROMINOLAR
    obstacles.forEach(o => o.draw(ctx));

    particles.forEach(p => p.draw(ctx));
    
    document.getElementById('hp-blue').style.width = P1.hp + "%";
    document.getElementById('hp-red').style.width = P2.hp + "%";

    requestAnimationFrame(gameLoop);
}

</script>
</body>
</html>
